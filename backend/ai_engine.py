import spacy
import re
import json
from transformers import pipeline
from deepdiff import DeepDiff

# Load Models
print("Loading Summarization Model...")
summarizer = pipeline("summarization", model="sshleifer/distilbart-cnn-12-6")

print("Loading Explainer Model...")
try:
    explainer = pipeline("text2text-generation", model="google/flan-t5-small")
except Exception as e:
    print(f"Warning: Could not load explainer model: {e}")
    explainer = None

print("Loading Scispacy Medical Model...")
try:
    # Use the installed small scientific model
    nlp = spacy.load("en_core_sci_sm")
except OSError:
    print("Warning: en_core_sci_sm not found, falling back to en_core_web_sm. Please install the model.")
    try:
        nlp = spacy.load("en_core_web_sm")
    except:
        from spacy.cli import download
        download("en_core_web_sm")
        nlp = spacy.load("en_core_web_sm")


from PIL import Image
import io

import torch
from transformers import MllamaForConditionalGeneration, AutoProcessor

# --- VISUAL MODELS ---
print("Loading Visual AI Models...")
llama_model = None
llama_processor = None
clip_classifier = None

# A. Try Loading Llama 3.2 Vision (11B)
# This requires HF_TOKEN and significant RAM (>20GB) or VRAM.
try:
    model_id = "meta-llama/Llama-3.2-11B-Vision-Instruct"
    print(f"Attempting to load {model_id}...")
    
    # Use device_map="auto" to offload to standard RAM if GPU/MPS is full
    # torch_dtype=torch.bfloat16 is standard for Llama 3 on recent hardware
    llama_model = MllamaForConditionalGeneration.from_pretrained(
        model_id,
        torch_dtype=torch.bfloat16,
        device_map="auto",
    )
    llama_processor = AutoProcessor.from_pretrained(model_id)
    print("SUCCESS: Llama 3.2 Vision Loaded!")
    
except Exception as e:
    print(f"Llama 3.2 Load Failed (Falling back to CLIP): {e}")
    # Common reasons: No HF_TOKEN, OOM, or model access not granted.

# B. Load CLIP (Zero-Shot) - Always load as fallback or primary if Llama fails
try:
    clip_classifier = pipeline("zero-shot-image-classification", model="openai/clip-vit-base-patch32")
    if not llama_model:
        print("Using CLIP as Primary Vision Model.")
except Exception as e:
    print(f"Warning: Could not load CLIP model: {e}")


def analyze_medical_image(image_bytes):
    """
    Analyzes an X-Ray/MRI image using Llama 3.2 (if avail) or CLIP.
    """
    # 1. Try Llama 3.2 Vision (Deep Analysis)
    if llama_model and llama_processor:
        try:
            image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
            
            # Simple Medical Prompt
            prompt = "<|image|><|begin_of_text|>Analyze this medical image. Describe findings and impression."
            inputs = llama_processor(image, prompt, return_tensors="pt").to(llama_model.device)
            
            output = llama_model.generate(**inputs, max_new_tokens=150)
            description = llama_processor.decode(output[0])
            
            # Cleanup output (remove prompt parts)
            description = description.replace(prompt, "").replace("<|begin_of_text|>", "").strip()
            
            return {
                "modality": "Medical Imaging (Llama 3.2 Analysis)",
                "predictions": [{"label": "Detailed Analysis", "confidence": 100}],
                "finding": description,
                "note": "Generated by Llama 3.2 Vision (11B). Validate clinically."
            }
        except Exception as e:
            print(f"Llama Inference Failed: {e}. Falling back to CLIP.")
            # Fallthrough to CLIP

    # 2. Fallback: CLIP (Modality Detection)
    if clip_classifier:
        try:
            image = Image.open(io.BytesIO(image_bytes)).convert("RGB")
            
            candidate_labels = [
                "chest x-ray", "brain mri", "abdominal ct scan", 
                "fetal ultrasound", "bone fracture", "medical document",
                "random noise", "random object"
            ]
            
            predictions = clip_classifier(image, candidate_labels=candidate_labels)
            
            formatted_preds = []
            is_medical_image = False
            top_label = predictions[0]['label']
            top_score = predictions[0]['score'] * 100
            
            for p in predictions[:3]:
                label = p['label']
                score = round(p['score'] * 100, 1)
                
                if any(x in label for x in ['x-ray', 'mri', 'ct scan', 'ultrasound', 'fracture', 'medical']):
                    if score > 20: is_medical_image = True
                    
                formatted_preds.append({"label": label.title(), "confidence": score})
                
            finding = f"Appearance consistent with {top_label.title()}"
            if top_label in ["random noise", "random object"] or top_score < 40:
                 finding = "Image classification uncertain. May not be a standard medical scan."
                 is_medical_image = False
                
            return {
                "modality": top_label.title() if is_medical_image else "Unknown",
                "predictions": formatted_preds,
                "finding": finding,
                "note": "AI modality detection (CLIP). For screening only."
            }
            
        except Exception as e:
            return {"error": f"CLIP Analysis Error: {str(e)}"}

    return {"error": "No Vision Models Available."}

REFERENCE_RANGES = {
    # Lipids
    "cholesterol": {"min": 0, "max": 200, "unit": "mg/dL"},
    "total cholesterol": {"min": 0, "max": 200, "unit": "mg/dL"},
    "hdl": {"min": 40, "max": 100, "unit": "mg/dL"},
    "ldl": {"min": 0, "max": 100, "unit": "mg/dL"},
    "triglycerides": {"min": 0, "max": 150, "unit": "mg/dL"},
    
    # Metabolic
    "glucose": {"min": 70, "max": 100, "unit": "mg/dL"},
    "fasting blood sugar": {"min": 70, "max": 100, "unit": "mg/dL"},
    "creatinine": {"min": 0.6, "max": 1.2, "unit": "mg/dL"},
    "bun": {"min": 7, "max": 20, "unit": "mg/dL"},
    "ast": {"min": 10, "max": 40, "unit": "U/L"},
    "sgot": {"min": 10, "max": 40, "unit": "U/L"},
    "alt": {"min": 7, "max": 56, "unit": "U/L"},
    "sgpt": {"min": 7, "max": 56, "unit": "U/L"},
    
    # CBC
    "hemoglobin": {"min": 13.5, "max": 17.5, "unit": "g/dL"},
    "hb": {"min": 13.5, "max": 17.5, "unit": "g/dL"},
    "wbc": {"min": 4.5, "max": 11.0, "unit": "x10^3/uL"},
    "white blood count": {"min": 4.5, "max": 11.0, "unit": "x10^3/uL"},
    "platelets": {"min": 150, "max": 450, "unit": "x10^3/uL"},
}

# Simple Medical Dictionary for Patient Translation
MEDICAL_DICTIONARY = {
    "osteopenia": "lower than normal bone density (warning sign for osteoporosis)",
    "pneumonia": "infection inflaming air sacs in one or both lungs",
    "hyperlipidemia": "high levels of fat particles (lipids) in the blood",
    "hypertension": "high blood pressure",
    "tachycardia": "faster than normal heart rate",
    "anemia": "lack of enough healthy red blood cells",
    "erythema": "redness of the skin",
    "edema": "swelling caused by excess fluid",
    "lesion": "damage or abnormal change in tissue",
    "benign": "not harmful in effect (not cancer)",
    "malignant": "very virulent or infectious (cancerous)",
    "stenosis": "narrowing of a passage in the body",
    "acute": "sudden and severe",
    "chronic": "persisting for a long time",
    "fracture": "broken bone"
}

SYNONYMS = {
    "hb": "hemoglobin",
    "hgb": "hemoglobin",
    "total cholesterol": "cholesterol",
    "t. chol": "cholesterol",
    "fbs": "glucose",
    "blood sugar": "glucose",
    "f.b.s": "glucose",
    "cre": "creatinine",
    "creat": "creatinine",
    "s. creatinine": "creatinine",
    "sgot": "ast",
    "asparts aminotransferase": "ast",
    "sgpt": "alt",
    "alanine aminotransferase": "alt",
    "trigs": "triglycerides",
    "pcv": "hematocrit",
    "hct": "hematocrit",
    "plt": "platelets",
    "platelet count": "platelets",
    "a1c": "hba1c",
    "hba1c": "hba1c",
    "glycated hemoglobin": "hba1c"
}

def normalize_name(name):
    clean = name.lower().strip().replace(":", "").replace(".", "")
    return SYNONYMS.get(clean, clean)

def extract_sections(text):
    """
    Intelligent splitting of the report into key sections.
    """
    sections = {
        "history": "",
        "findings": "",
        "impression": ""
    }
    
    # Normalize keys/headers
    text_lower = text.lower()
    
    # Heuristic indices
    idx_history = text_lower.find("history:") 
    if idx_history == -1: idx_history = text_lower.find("clinical history:")
    
    idx_findings = text_lower.find("findings:") 
    if idx_findings == -1: idx_findings = text_lower.find("technique:") # fallback
    
    idx_impression = text_lower.find("impression:")
    if idx_impression == -1: idx_impression = text_lower.find("conclusion:")
    if idx_impression == -1: idx_impression = text_lower.find("diagnosis:")

    # Sort indices to know order
    indices = sorted([
        (idx_history, "history"), 
        (idx_findings, "findings"), 
        (idx_impression, "impression")
    ], key=lambda x: x[0])
    
    # Extract
    for i, (idx, key) in enumerate(indices):
        if idx == -1: continue
        
        start = idx + len(key) + 1 # +1 for colon
        end = len(text)
        
        # Find start of next section used as end of current
        if i + 1 < len(indices):
            next_idx = indices[i+1][0]
            if next_idx != -1:
                end = next_idx
        
        content = text[start:end].strip()
        sections[key] = content

    # Fallback: if no structure found, put everything in findings
    if not any(sections.values()):
        sections["findings"] = text
        
    return sections

def simplify_text(text):
    """
    Translates medical terms to plain English using Dictionary (Fallback).
    """
    words = text.split()
    simplified = []
    
    for word in words:
        clean_word = word.lower().strip(".,()[]")
        if clean_word in MEDICAL_DICTIONARY:
            # Append term + explanation
            simplified.append(f"{word} ({MEDICAL_DICTIONARY[clean_word]})")
        else:
            simplified.append(word)
            
    return " ".join(simplified)

def explain_to_patient(text):
    """
    Uses LLM to generate a patient-friendly explanation.
    """
    if not text or not text.strip():
        return "No significant findings to explain."
        
    if not explainer:
        return simplify_text(text)
        
    try:
        # Prompt Engineering for Flan-T5
        prompt = f"Explain this medical finding to a patient in simple words: {text}"
        output = explainer(prompt, max_length=128, do_sample=False)
        return output[0]['generated_text']
    except Exception as e:
        print(f"Explainer Error: {e}")
        return simplify_text(text)

def detect_severity(text):
    """
    Detects severity from adjectives in the text.
    """
    text_lower = text.lower()
    if any(x in text_lower for x in ["critical", "severe", "emergency", "acute distress"]):
        return {"level": "Severe", "color": "red"}
    elif any(x in text_lower for x in ["moderate", "elevated", "abnormal"]):
        return {"level": "Moderate", "color": "orange"}
    elif any(x in text_lower for x in ["mild", "trace", "minor", "borderline"]):
         return {"level": "Mild", "color": "yellow"}
    
    return {"level": "Normal", "color": "green"}

def extract_labs_regex(text):
    """
    Improved regex to catch more variations (plain and bracketed types).
    """
    labs = []
    
    # Pattern 1: Name: Value Unit (e.g. Hemoglobin: 13.5 g/dL)
    # Also catches: Name 13.5 Unit (no colon)
    # Updated to handle Ranges like [ 13.0 - 17.0 ] usually appearing after value/unit
    pattern = re.compile(r"([A-Za-z\s\(\)\-\.]+?)[:\s]+(\d+(?:\.\d+)?)\s*([a-zA-Z%\^/0-9]+)")
    
    found_names = set()

    for match in pattern.finditer(text):
        raw_name = match.group(1).strip()
        value = float(match.group(2))
        unit = match.group(3).strip()
        
        if len(raw_name) < 2 or raw_name.lower() in ["page", "date", "dob", "specimen", "patient", "collected", "reported"]:
            continue
            
        normalized = normalize_name(raw_name)
        ref = REFERENCE_RANGES.get(normalized)
        
        # Validation: If not in our KB, check if unit looks "lab-like"
        known_units = ["mg/dl", "g/dl", "u/l", "mmol/l", "%", "x10^3/ul", "fl", "pg", "iu/l"]
        if not ref and unit.lower() not in known_units:
            continue

        if normalized in found_names: continue

        status = "Normal"
        ref_str = "N/A"
        
        if ref:
            ref_str = f"{ref['min']}-{ref['max']} {ref['unit']}"
            if value < ref['min']:
                status = "Low"
            elif value > ref['max']:
                status = "High"
        
        labs.append({
            "name": raw_name,
            "normalized_name": normalized,
            "value": value,
            "unit": unit,
            "status": status,
            "reference": ref_str
        })
        found_names.add(normalized)
        
    return labs

def calculate_risk(labs):
    risks = []
    lab_map = {l['normalized_name']: l for l in labs}
    
    # CV Risk
    chol = lab_map.get('cholesterol')
    ldl = lab_map.get('ldl')
    if chol and chol['value'] > 240:
        risks.append({"type": "Cardiovascular", "status": "High Risk", "detail": "Total Cholesterol > 240"})
    elif chol and chol['value'] > 200:
        risks.append({"type": "Cardiovascular", "status": "Moderate Risk", "detail": "Total Cholesterol > 200"})
    elif ldl and ldl['value'] > 160:
        risks.append({"type": "Cardiovascular", "status": "High Risk", "detail": "LDL > 160"})

    # Diabetes
    gluc = lab_map.get('glucose')
    if gluc and gluc['value'] > 126:
        risks.append({"type": "Diabetes", "status": "High Risk", "detail": "Fasting Glucose > 126"})
        
    # Kidney
    creat = lab_map.get('creatinine')
    if creat and creat['value'] > 1.4:
         risks.append({"type": "Kidney Health", "status": "Elevated Risk", "detail": "Creatinine High"})

    return risks

def generate_recommendations(labs, risks):
    recs = []
    lab_map = {l['normalized_name']: l for l in labs}

    if any(r['type'] == 'Cardiovascular' for r in risks):
        recs.append({"action": "Diet", "advice": "Reduce saturated fats and cholesterol intake. Consider Mediterranean diet."})
        recs.append({"action": "Exercise", "advice": "Aim for 150 minutes of moderate aerobic activity per week."})
    
    if any(r['type'] == 'Diabetes' for r in risks):
         recs.append({"action": "Diet", "advice": "Monitor carbohydrate intake. Avoid sugary beverages."})
         recs.append({"action": "Monitoring", "advice": "Check HbA1c to assess long-term glucose control."})

    if not recs:
        recs.append({"action": "General", "advice": "Maintain current healthy lifestyle."})
        recs.append({"action": "Screening", "advice": "Routine annual physical."})
    else:
        recs.append({"action": "Follow-up", "advice": "Repeat lipids/metabolic panel in 3-6 months."})

    return recs

def summarize_text(text):
    if len(text) > 2000:
        text = text[:2000]
    try:
        summary = summarizer(text, max_length=150, min_length=40, do_sample=False)
        return summary[0]['summary_text']
    except:
        return "Summary unavailable."

def get_follow_up_tests(labs, risks):
    tests = []
    lab_map = {l['normalized_name']: l for l in labs}
    
    # 1. Lipid / Cardiovascular
    if any(r['type'] == 'Cardiovascular' for r in risks):
        tests.append({
            "test": "Lipid Fractionation",
            "reason": "Detailed breakdown of cholesterol particles to assess risk more accurately."
        })
        tests.append({
            "test": "Lipoprotein(a)",
            "reason": "Genetic marker for cardiovascular risk."
        })
        tests.append({
            "test": "ApoB",
            "reason": "Direct measure of atherogenic particles."
        })

    # 2. Diabetes / Metabolic
    glucose = lab_map.get('glucose')
    hba1c = lab_map.get('hba1c')
    if (glucose and glucose['status'] == 'High') or (hba1c and hba1c['status'] == 'High'):
        tests.append({
            "test": "C-Peptide & Insulin",
            "reason": "Distinguish between Type 1 and Type 2 diabetes / assess insulin resistance."
        })
        tests.append({
            "test": "Urine Microalbumin",
            "reason": "Screen for early kidney damage due to sugar levels."
        })

    # 3. Anemia
    hemoglobin = lab_map.get('hemoglobin')
    if hemoglobin and hemoglobin['status'] == 'Low':
        tests.append({
            "test": "Iron Studies (Ferritin, TIBC)",
            "reason": "Determine if anemia is due to iron deficiency."
        })
        tests.append({
            "test": "Vitamin B12 & Folate",
            "reason": "Rule out nutritional deficiency."
        })
        tests.append({
            "test": "Reticulocyte Count",
            "reason": "Check bone marrow response to anemia."
        })

    # 4. Thyroid
    tsh = lab_map.get('tsh')
    if tsh and tsh['status'] != 'Normal':
        tests.append({
            "test": "Free T3 & Free T4",
            "reason": "Confirm extent of thyroid dysfunction."
        })
        tests.append({
            "test": "Thyroid Antibodies (TPO)",
            "reason": "Check for autoimmune causes like Hashimoto's."
        })

    # 5. Inflammation / Infection
    wbc = lab_map.get('wbc')
    if wbc and wbc['status'] == 'High':
        tests.append({
            "test": "WBC Differential",
            "reason": "Identify if infection is bacterial, viral, or other."
        })
        tests.append({
            "test": "CRP & ESR",
            "reason": "General markers of inflammation in the body."
        })

    # 6. Liver
    alt = lab_map.get('alt')
    ast = lab_map.get('ast')
    if (alt and alt['status'] == 'High') or (ast and ast['status'] == 'High'):
        tests.append({
            "test": "Hepatitis Panel",
            "reason": "Rule out viral hepatitis."
        })
        tests.append({
            "test": "Abdominal Ultrasound",
            "reason": "Check for fatty liver or structural issues."
        })
        
    return tests

def compare_labs(current_labs, previous_labs):
    """
    Matches labs by normalized name and calculates trends.
    """
    prev_map = {l['normalized_name']: l for l in previous_labs}
    
    for lab in current_labs:
        norm = lab['normalized_name']
        if norm in prev_map:
            prev = prev_map[norm]
            lab['previous_value'] = prev['value']
            
            diff = lab['value'] - prev['value']
            lab['change'] = round(diff, 2)
            
            # Trend Logic
            # For most things, lower is better if it was High, higher is better if Low.
            # Simplified Logic:
            if abs(diff) < 0.1:
                lab['trend'] = 'Stable'
            elif diff > 0:
                lab['trend'] = 'Increasing'
            else:
                lab['trend'] = 'Decreasing'
                
            # Heuristic for "Better/Worse" (Very basic)
            if lab['status'] == 'High' and diff < 0:
                lab['trend_context'] = 'Improving'
            elif lab['status'] == 'Low' and diff > 0:
                lab['trend_context'] = 'Improving'
            elif lab['status'] == 'Normal':
                lab['trend_context'] = 'Stable'
            else:
                lab['trend_context'] = 'Worsening'
                
    return current_labs

def analyze_full_report(current_text, previous_text=None):
    # 1. Structural Parsing
    sections = extract_sections(current_text)
    
    # 2. Lab Extraction
    labs = extract_labs_regex(current_text)
    
    # 3. Risk & Recs
    risks = calculate_risk(labs)
    recommendations = generate_recommendations(labs, risks)
    follow_up_tests = get_follow_up_tests(labs, risks)
    
    # 4. Intelligence Layers
    # Patient-Friendly Translation of Findings/Impression
    patient_findings = explain_to_patient(sections['findings'])
    patient_impression = explain_to_patient(sections['impression'])
    
    # Severity Detection per section
    severity = {
        "findings": detect_severity(sections['findings']),
        "impression": detect_severity(sections['impression'])
    }
    
    # 5. Summary (Technical)
    summary = summarize_text(current_text)
    
    # Entities
    doc = nlp(current_text)
    entities = [{"text": e.text, "label": "ENTITY"} for e in doc.ents]
    entities = [dict(t) for t in {tuple(d.items()) for d in entities}]

def detect_report_type(text):
    """
    Determines if the report is 'Lab' or 'Radiology' based on keywords.
    """
    text_lower = text.lower()
    
    # Radiology Signals
    rad_keywords = [
        "mri", "ct scan", "computed tomography", "x-ray", "ultrasound", 
        "sonography", "technique:", "exam:", "examination:", "contrast", 
        "sagittal", "coronal", "axial", "t1", "t2", "echo", "doppler"
    ]
    
    # Lab Signals
    lab_keywords = [
        "hemoglobin", "glucose", "cholesterol", "creatinine", 
        "reference range", "units", "u/l", "mg/dl", "g/dl"
    ]
    
    rad_score = sum(1 for k in rad_keywords if k in text_lower)
    lab_score = sum(1 for k in lab_keywords if k in text_lower)
    
    if rad_score > lab_score:
        return "Radiology"
    return "Lab"

def analyze_radiology(text, sections):
    """
    Specialized analysis for imaging reports.
    """
    findings = sections.get('findings', '')
    impression = sections.get('impression', '')
    
    # NLP Extraction for Abnormalities
    doc = nlp(findings + " " + impression)
    
    # Heuristic: Find sentences with 'alert' words
    abnormalities = []
    alert_terms = [
        "mass", "nodule", "fracture", "herniation", "stenosis", 
        "lesion", "cyst", "tumor", "infarct", "hemorrhage", 
        "effusion", "opacification", "tear", "rupture", "dislocation"
    ]
    
    for sent in doc.sents:
        sent_text = sent.text.strip()
        if any(term in sent_text.lower() for term in alert_terms):
            # Check if it is negated? (Basic check)
            if "no " not in sent_text.lower() and "unremarkable" not in sent_text.lower():
                abnormalities.append(sent_text)
                
    # Deduplicate
    abnormalities = list(set(abnormalities))
    
    return {
        "modality": "Unknown Imaging", # Could extract "MRI of Brain" here later
        "abnormalities": abnormalities,
        "is_normal": len(abnormalities) == 0
    }


def get_recommended_specialists(risks, report_type="Lab"):
    """
    Maps risks/abnormalities to medical specialists.
    """
    specialists = set()
    
    # 1. Logic based on Risks (Lab/General)
    for risk in risks:
        r_type = risk.get('type', '').lower()
        detail = risk.get('detail', '').lower()
        
        if "cardiovascular" in r_type or "cholesterol" in detail:
            specialists.add("Cardiologist")
        elif "diabetes" in r_type or "glucose" in detail or "thyroid" in detail:
            specialists.add("Endocrinologist")
        elif "kidney" in r_type or "creatinine" in detail:
            specialists.add("Nephrologist")
        elif "anemia" in r_type or "hemoglobin" in detail:
            specialists.add("Hematologist")
        elif "liver" in r_type or "hepatitis" in detail:
            specialists.add("Hepatologist")
            
    # 2. Logic based on Radiology Findings
    if report_type == "Radiology":
        # Broad mapping based on likely body parts (basic heuristic)
        # In a real app, we'd check if "Brain MRI" -> Neurologist
        pass 
        
    # Default fallbacks
    if not specialists:
        if report_type == "Radiology":
             specialists.add("Orthopedist") # skeletal stuff
             specialists.add("Radiologist") # for consult
        else:
             specialists.add("Primary Care Physician")
             
    return list(specialists)

def analyze_full_report(current_text, previous_text=None):
    # 1. Structural Parsing (Common for both)
    sections = extract_sections(current_text)
    
    # 2. Detect Type
    report_type = detect_report_type(current_text)
    
    # 3. Summary (Common)
    summary = summarize_text(current_text)
    
    # 4. Entities (Common)
    doc = nlp(current_text)
    entities = [{"text": e.text, "label": "ENTITY"} for e in doc.ents]
    entities = [dict(t) for t in {tuple(d.items()) for d in entities}]
    
    result = {
        "report_type": report_type,
        "summary": summary,
        "sections": sections,
        "entities": entities
    }

    if report_type == "Radiology":
        rad_analysis = analyze_radiology(current_text, sections)
        
        # Patient Explanation for Radiology
        patient_impression = explain_to_patient(sections['impression'])
        
        # Calculate Specialists for Radiology (Basic)
        # If fracture -> Orthopedist
        specialists = ["Primary Care Physician"]
        for ab in rad_analysis.get('abnormalities', []):
            if "fracture" in ab.lower() or "bone" in ab.lower():
                 specialists.append("Orthopedist")
            if "tumor" in ab.lower() or "mass" in ab.lower():
                 specialists.append("Oncologist")
        specialists = list(set(specialists))

        result.update({
            "radiology": rad_analysis,
            "patient_view": {
                "findings": "See imaging details below.",
                "impression": patient_impression,
                "explanation": "Imaging reports describe visual findings. We've highlighted key abnormalities."
            },
            "risks": [], 
            "labs": [], 
            "recommendations": [],
            "follow_up_tests": [],
            "specialists": specialists 
        })
        
        if rad_analysis['abnormalities']:
            result['risks'].append({"type": "Imaging Finding", "status": "Observation", "detail": "Abnormalities detected in scan."})
            
    else:
        # Standard Lab Analysis
        labs = extract_labs_regex(current_text)
        risks = calculate_risk(labs)
        recommendations = generate_recommendations(labs, risks)
        follow_up_tests = get_follow_up_tests(labs, risks)
        
        # V16: Specialist Mapping
        specialists = get_recommended_specialists(risks, "Lab")
        
        patient_findings = explain_to_patient(sections['findings'])
        patient_impression = explain_to_patient(sections['impression'])
        
        severity = {
            "findings": detect_severity(sections['findings']),
            "impression": detect_severity(sections['impression'])
        }
        
        comparison = {}
        if previous_text:
            prev_labs = extract_labs_regex(previous_text)
            labs = compare_labs(labs, prev_labs)
            comparison = {
                "previous_labs": prev_labs,
                "diff_summary": f"Compared against previous report." 
            }
            
        result.update({
            "patient_view": {
                "findings": patient_findings,
                "impression": patient_impression,
                "explanation": "Simplified medical terms are shown in parentheses."
            },
            "severity": severity,
            "labs": labs,
            "risks": risks,
            "recommendations": recommendations,
            "follow_up_tests": follow_up_tests,
            "comparison": comparison,
            "specialists": specialists
        })

    return result
